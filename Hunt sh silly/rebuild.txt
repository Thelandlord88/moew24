Absolutely—you can nuke the current page set and rebuild around a tight, props-driven Astro setup while keeping all legacy bits (CSS, components, snippets) safely archived. Here’s a clean, low-risk way to do it that sets you up for geo-driven service pages going forward.

# Goal

* **Archive (don’t ship) today’s pages** so nothing under `src/pages/**` leaks into the build.
* **Keep** CSS, design tokens, and any reusable UI primitives handy.
* **Stand up a single parametric route** `src/pages/services/[service]/[suburb].astro` with a typed props layer so new services/suburbs are just data.

---

## 1) Create a safe archive snapshot (Git + folder)

This gives you a “panic button” and keeps the repo tidy.

```bash
# 1) Branch + tag your current state
git checkout -b reset/astro-props-rebuild
git tag legacy-pre-astro-props

# 2) Make a top-level archive folder that Astro won't build
mkdir -p legacy/{pages,components,styles,snippets}

# 3) Move the old pages out of the build path
git mv src/pages legacy/pages

# (Optional) If you know some components/layouts are purely page-specific, archive them too
# git mv src/layouts legacy/layouts
# git mv src/components/old-* legacy/components/

# 4) Keep styles accessible: if all your CSS lives under src/styles keep it there.
#    If any page-inline CSS existed in old pages, copy them into legacy/styles for reference.
#    (Don’t remove src/styles unless you *want* to)
# Example (copy, not move):
# cp -r legacy/pages/**/styles/*.css legacy/styles/ 2>/dev/null || true

# 5) Add ignores so tools don’t lint/typecheck legacy
echo "legacy/**" >> .eslintignore
echo "legacy/**" >> .prettierignore

# 6) Exclude legacy from TS
# tsconfig.json → "exclude": ["legacy/**", "node_modules", "dist"]

git add -A
git commit -m "chore(archive): move old pages to /legacy and exclude from build"
```

Now the build will have **zero routes**, which is what you want before adding back your new, props-driven system.

---

## 2) Minimal fresh scaffold

Create a tiny homepage and the unified service route.

```bash
# Home (placeholder)
mkdir -p src/pages
cat > src/pages/index.astro <<'ASTRO'
---
const title = "One N Done";
const desc = "Brisbane • Ipswich • Logan — Professional cleaning";
---
<html lang="en">
  <head><title>{title}</title><meta name="description" content={desc} /></head>
  <body class="min-h-screen">
    <main class="mx-auto max-w-3xl p-6">
      <h1 class="text-3xl font-bold">New build in progress</h1>
      <p>Routes will be generated from geo + service data.</p>
    </main>
  </body>
</html>
ASTRO
```

---

## 3) Centralize your geo + services config (typed)

One source of truth that every page pulls props from.

```ts
// src/lib/geo/types.ts
import { z } from "zod";

export const Services = z.enum(["bond-cleaning","bathroom-deep-clean","spring-cleaning"]);
export type ServiceSlug = z.infer<typeof Services>;

export const Coords = z.object({ lat: z.number(), lng: z.number() });
export const Suburb = z.object({
  slug: z.string(),          // e.g. "springfield"
  name: z.string(),          // "Springfield"
  cluster: z.enum(["brisbane","ipswich","logan"]),
  coords: Coords
});
export type SuburbT = z.infer<typeof Suburb>;

export type GeoPageCtx = {
  suburb: SuburbT;
  service: ServiceSlug;
  neighbors: string[];           // slugs
  otherServices: ServiceSlug[];  // what else we offer in this suburb
};

// src/lib/services/config.ts
export const SERVICE_META: Record<ServiceSlug, {
  label: string;
  path: string;  // folder segment
  h1: (s: string) => string;
  description: (s: string) => string;
}> = {
  "bond-cleaning": {
    label: "Bond Clean",
    path: "bond-cleaning",
    h1: (s) => `${s} Bond Clean`,
    description: (s) => `Agent-ready bond cleaning in ${s}. Fixed-quote, thorough, on time.`
  },
  "bathroom-deep-clean": {
    label: "Bathroom Deep Clean",
    path: "bathroom-deep-clean",
    h1: (s) => `${s} Bathroom Deep Clean`,
    description: (s) => `A meticulous bathroom deep clean for homes in ${s}.`
  },
  "spring-cleaning": {
    label: "Spring Clean",
    path: "spring-cleaning",
    h1: (s) => `${s} Spring Clean`,
    description: (s) => `A seasonal, top-to-bottom refresh for ${s}.`
  }
} as const;
```

Back your data however you like (JSON files, a small TS module, or content collections). Typical simple setup:

```
src/data/
  suburbs.json              # [{slug,name,cluster,coords:{lat,lng}}, ...]
  adjacency.json            # { [slug]: [neighborSlug,...], ... }
  coverage.json             # { [serviceSlug]: [suburbSlug,...], ... }
```

Loaders:

```ts
// src/lib/geo/data.ts
import fs from "node:fs"; import path from "node:path";
import { z } from "zod";
import { Services, Suburb, type ServiceSlug, type GeoPageCtx } from "./types";
import { SERVICE_META } from "../services/config";

const DATA = (p: string) => path.join(process.cwd(), "src/data", p);
const read = <T>(p: string) => JSON.parse(fs.readFileSync(DATA(p), "utf8")) as T;

const suburbsA = z.array(Suburb);
type SuburbArr = ReturnType<typeof suburbsA["parse"]>;

const suburbs   = suburbsA.parse(read<unknown>("suburbs.json"));
const adjacency = read<Record<string,string[]>>("adjacency.json");
const coverage  = read<Record<string,string[]>>("coverage.json");

const bySlug = new Map(suburbs.map(s => [s.slug, s]));
export const listCovered = (svc: ServiceSlug) =>
  (coverage[svc] || []).filter(slug => bySlug.has(slug)).sort();

export function buildCtx(suburbSlug: string, service: ServiceSlug): GeoPageCtx {
  const suburb = bySlug.get(suburbSlug);
  if (!suburb) throw new Error(`Unknown suburb: ${suburbSlug}`);
  const others = (Object.keys(coverage) as ServiceSlug[])
    .filter(s => s !== service && (coverage[s] || []).includes(suburbSlug))
    .sort();
  const sameClusterNeighbors = (adjacency[suburbSlug] || [])
    .filter(n => bySlug.get(n)?.cluster === suburb.cluster)
    .slice(0, 12); // cap
  return { suburb, service, neighbors: sameClusterNeighbors, otherServices: others };
}
```

---

## 4) One parametric route for everything

This keeps your integration tight and future-proof.

```
src/pages/services/[service]/[suburb].astro
```

```astro
---
import type { ServiceSlug } from "~/lib/geo/types";
import { SERVICE_META } from "~/lib/services/config";
import { listCovered, buildCtx } from "~/lib/geo/data";

export async function getStaticPaths() {
  const services = Object.keys(SERVICE_META) as ServiceSlug[];
  return services.flatMap((svc) =>
    listCovered(svc).map((suburb) => ({ params: { service: svc, suburb } }))
  );
}

const { service, suburb } = Astro.params as { service: ServiceSlug; suburb: string };
const ctx = buildCtx(suburb, service);

const meta = SERVICE_META[service];
const title = `${meta.h1(ctx.suburb.name)} | One N Done`;
const desc  = meta.description(ctx.suburb.name);
const canonical = `/services/${meta.path}/${ctx.suburb.slug}/`;
---

<html lang="en">
  <head>
    <title>{title}</title>
    <meta name="description" content={desc} />
    <link rel="canonical" href={canonical} />
  </head>
  <body class="min-h-screen">
    <main class="mx-auto max-w-5xl p-6">
      <h1 class="text-3xl font-bold">{meta.h1(ctx.suburb.name)}</h1>
      <p class="mt-2">{desc}</p>

      <!-- Other services in this suburb -->
      {ctx.otherServices.length > 0 && (
        <section class="mt-8">
          <h2 class="text-xl font-semibold">Other services in {ctx.suburb.name}</h2>
          <ul class="grid sm:grid-cols-2 gap-3 mt-3">
            {ctx.otherServices.map(os => (
              <li>
                <a href={`/services/${SERVICE_META[os].path}/${ctx.suburb.slug}/`}>
                  {SERVICE_META[os].label}
                </a>
              </li>
            ))}
          </ul>
        </section>
      )}

      <!-- Nearby suburbs -->
      <section class="mt-10">
        <h2 class="text-xl font-semibold">Nearby suburbs</h2>
        <ul class="grid sm:grid-cols-2 md:grid-cols-3 gap-2 mt-3">
          {ctx.neighbors.map(n => (
            <li><a href={`/services/${SERVICE_META[service].path}/${n}/`}>{n.replace(/-/g," ")}</a></li>
          ))}
        </ul>
      </section>
    </main>
  </body>
</html>
```

This single file covers **Bond Clean**, **Bathroom Deep Clean**, and **Spring Clean** for **all suburbs**—purely from data. Adding a new service or suburb is just updating `coverage.json` (and a label/description in `SERVICE_META`).

---

## 5) Keep and re-use your CSS (cleanly)

* **Leave `src/styles/**` in place** so your Tailwind/global CSS remains; only page files were archived.
* If you had valuable CSS embedded in old pages, keep those copies in `legacy/styles/` and cherry-pick rules into your new global CSS or component CSS as needed.
* Consider extracting your tokens to Tailwind config (if not already):

  ```js
  // tailwind.config.js
  export default {
    content: ["./src/**/*.{astro,ts,tsx,mdx,md}"],
    theme: {
      extend: {
        colors: {
          brand: { primary: "#0f172a", accent: "#38bdf8" },
        },
        borderRadius: { xl: "1rem", "2xl": "1.25rem" },
      }
    }
  }
  ```

---

## 6) Wiring & guardrails

Add a basic doctor to ensure your new data stays healthy:

```bash
mkdir -p scripts/geo
cat > scripts/geo/doctor.mjs <<'JS'
#!/usr/bin/env node
import fs from "node:fs"; import path from "node:path";
const D = p => JSON.parse(fs.readFileSync(path.join("src/data", p), "utf8"));
const suburbs = D("suburbs.json"); const adjacency = D("adjacency.json"); const coverage = D("coverage.json");
const slugs = new Set(suburbs.map(s => s.slug));
let ok = true;

function check(name, cond, msg) { if (!cond) { console.error("×", name, "—", msg); ok = false; } else { console.log("✓", name); } }

check("coords coverage", suburbs.every(s => typeof s.coords?.lat === "number" && typeof s.coords?.lng === "number"), "missing lat/lng");
check("adjacency symmetry", Object.entries(adjacency).every(([a,ns]) => ns.every(b => (adjacency[b]||[]).includes(a))), "non-symmetric edges");
check("coverage known slugs", Object.values(coverage).flat().every(s => slugs.has(s)), "coverage points to unknown suburb");
process.exit(ok ? 0 : 1);
JS

# package.json
npm pkg set scripts.geo:doctor="node scripts/geo/doctor.mjs"
```

Run it before build:

```json
// package.json
{
  "scripts": {
    "build": "npm run geo:doctor && astro build"
  }
}
```

---

## 7) Sanity checklist (quick)

* `legacy/**` exists and is excluded from lint/TS.
* `src/pages/services/[service]/[suburb].astro` builds and lists the right paths.
* `coverage.json` includes your initial services/suburbs (start with Bond Clean; add the other two next).
* CSS renders (Tailwind/global) without relying on archived pages.

---

## 8) Common Qs

**Can I delete everything under `src/pages/**`?**
Yes—after you’ve moved it into `legacy/pages/`. Anything under `legacy/` won’t be part of the Astro router or build.

**What if I need an old CSS snippet?**
Grab it from `legacy/styles/` (or `legacy/pages/**`), then fold it into your new global CSS or component-scoped CSS.

**How do I add a new service later?**

1. Add a key to `SERVICE_META`. 2) Add its suburbs to `coverage.json`. Done—the param route covers it.

---

## 9) Optional: one-command helper to archive pages

Drop this into `scripts/reset/archive-pages.mjs` if you want to automate future resets:

```js
#!/usr/bin/env node
import fs from "node:fs"; import path from "node:path"; import cp from "node:child_process";

const srcPages = path.join("src","pages");
const dest = path.join("legacy","pages_" + new Date().toISOString().slice(0,10));
fs.mkdirSync("legacy", { recursive: true });
if (fs.existsSync(srcPages)) {
  cp.execSync(`git mv ${srcPages} ${dest}`, { stdio: "inherit" });
  fs.mkdirSync(srcPages, { recursive: true }); // leave empty pages dir
  console.log(`Archived ${srcPages} -> ${dest}`);
} else {
  console.log("No src/pages found; nothing to archive.");
}
```

```bash
chmod +x scripts/reset/archive-pages.mjs
npm pkg set scripts.reset:pages="node scripts/reset/archive-pages.mjs"
npm run reset:pages
```

---

### Bottom line

* Move all current routes to `/legacy` (kept, not shipped).
* Stand up **one** typed, parametric Astro route that reads geo + service data.
* Keep `src/styles/**` and tokens in place; cherry-pick any legacy CSS when needed.
* Add a tiny doctor so data changes don’t silently break route generation.

This gives you a clean slate and a tight, props-first integration—ready for your Brisbane/Ipswich/Logan geo rollout and any new services you dream up.
