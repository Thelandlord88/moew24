#!/usr/bin/env node
// Generate a centralized knowledge base into REPO_FILES.md.
// - Uses git history for Created / Last Edited.
// - "What / Why" heuristics; if unknown -> "n/a".
// Usage examples:
//   node scripts/generate-knowledge-base.mjs
//   node scripts/generate-knowledge-base.mjs --include "^src/" --out MY_FILE.md

import { execFileSync } from 'node:child_process';
import { writeFileSync } from 'node:fs';
import { basename } from 'node:path';

// ---------- args ----------
const args = process.argv.slice(2);
const OUT = readOpt('--out', 'REPO_FILES.md');
const inc = readOpt('--include', null);
const exc = readOpt('--exclude', null);
const INCLUDE = inc ? new RegExp(inc) : null;
const EXCLUDE = exc ? new RegExp(exc) : null;

function readOpt(flag, def) {
  const i = args.indexOf(flag);
  return i >= 0 ? args[i + 1] : def;
}

// ---------- helpers ----------
function sh(cmd, cmdArgs) {
  try {
    const out = execFileSync(cmd, cmdArgs, { encoding: 'utf8', stdio: ['ignore', 'pipe', 'pipe'] });
    return out.trim();
  } catch {
    return '';
  }
}

function gitFiles() {
  const out = sh('git', ['ls-files']);
  return out ? out.split('\n').filter(Boolean) : [];
}

function firstCommitInfo(path) {
  const dates = sh('git', ['log', '--diff-filter=A', '--follow', '--format=%ci', '--', path]).split('\n').filter(Boolean);
  const hashes = sh('git', ['log', '--diff-filter=A', '--follow', '--format=%H', '--', path]).split('\n').filter(Boolean);
  let date = dates.pop();
  let hash = hashes.pop();
  if (!date || !hash) {
    const d2 = sh('git', ['log', '--follow', '--format=%ci', '--reverse', '--', path]).split('\n').filter(Boolean);
    const h2 = sh('git', ['log', '--follow', '--format=%H', '--reverse', '--', path]).split('\n').filter(Boolean);
    date = d2[0]; hash = h2[0];
  }
  return { date: sanitizeDate(date), hash: hash || 'n/a' };
}

function lastCommitInfo(path) {
  const date = sh('git', ['log', '-1', '--format=%ci', '--', path]) || '';
  const hash = sh('git', ['log', '-1', '--format=%H', '--', path]) || '';
  return { date: sanitizeDate(date), hash: hash || 'n/a' };
}

function sanitizeDate(ci) {
  if (!ci) return 'n/a';
  const m = ci.match(/^(\d{4}-\d{2}-\d{2})/);
  return m ? m[1] : ci;
}

function keep(path) {
  if (INCLUDE && !INCLUDE.test(path)) return false;
  if (EXCLUDE && EXCLUDE.test(path)) return false;
  return true;
}

// WHAT / WHY / CONNECTS heuristics (regex, what, why, connects)
const H = [
  [/^src\/middleware\.ts$/i, 'Edge middleware for redirects.', 'Handle canonical + alias redirects early.', 'Invoked by platform runtime before routes'],
  [/public\/_redirects$/i, 'Static redirect rules.', 'Enforce legacy URL canonicalization.', 'Consumed by Netlify/CDN; complements middleware'],
  [/public\/_headers$/i, 'Static header rules.', 'Security + caching headers.', 'Deployed with site; affects all requests'],
  [/src\/utils\/internalLinks\.ts$/i, 'Internal link helpers.', 'Cross-service + local guide link generation.', 'Used by CrossServiceLinks & related components'],
  [/src\/components\/CrossServiceLinks\.astro$/i, 'Cross-service link UI.', 'Boost onward CTR with contextual links.', 'Rendered in ServiceLayout & blog pages'],
  [/src\/utils\/repSuburb\.ts$/i, 'Representative suburb logic.', 'Pick central suburb by adjacency degree.', 'Called by blog/service linking utilities'],
  [/src\/utils\/nearbyCovered\.ts$/i, 'Nearby covered suburb logic.', 'Fallback to closest covered suburb.', 'Used when service not offered in current suburb'],
  [/src\/utils\/chooseSuburbForPost\.ts$/i, 'Blog suburb selector.', 'Derives best suburb for a post for links.', 'Used in blog page templates'],
  [/astro\.config\.mjs$/i, 'Astro configuration.', 'Build/runtime project settings.', 'Loaded by Astro build/dev'],
  [/README\.md$/i, 'Project overview.', 'Developer onboarding & usage.', 'Linked in repository root'],
  [/CONTRIBUTING\.md$/i, 'Contribution guide.', 'Standards for PRs & quality.', 'Referenced by contributors/CI reviews'],
  [/^scripts\//i, 'Project script.', 'Automation / build or audit task.', 'Invoked via npm scripts'],
  [/^__ai\//i, 'AI/audit artifact.', 'Stores build or analysis output.', 'Produced by ai-* or audit scripts'],
  [/^ai-reports\//i, 'AI enrichment report.', 'Holds enrichment JSON output.', 'Generated by ai-enrichment scripts'],
  [/ai-rules\.json$/i, 'AI lint rules.', 'Defines copy/intent lint policies.', 'Consumed by ai-copy-lint script'],
  [/cypress\.config\.js$/i, 'Cypress config.', 'E2E test runner settings.', 'Used by cypress tests in cypress/e2e'],
  [/^cypress\/e2e\//i, 'Cypress test spec.', 'Browser flow / UI validation.', 'Run under Cypress runner'],
  [/playwright\.config\.ts$/i, 'Playwright config.', 'E2E+visual test settings.', 'Used by Playwright test suite'],
  [/^tests\/.*visual.*\.spec\.ts$/i, 'Visual test spec.', 'Baseline screenshot regression.', 'Executed by Playwright'],
  [/^tests\//i, 'Test file.', 'Automated behaviour verification.', 'Executed via vitest/playwright'],
  [/tailwind\.config\.js$/i, 'Tailwind config.', 'Utility class generation.', 'Used by build (PostCSS) to emit CSS'],
  [/^css\/output\.css$/i, 'Compiled CSS bundle.', 'Generated Tailwind styles.', 'Linked by layouts (MainLayout)'],
  [/^public\//i, 'Static asset.', 'Served directly to clients.', 'Referenced by pages/layouts'],
  [/\.astro$/i, 'Astro component/page.', 'Route or UI composition.', 'Imported/rendered by layouts/pages'],
  [/\.(ts|tsx)$/i, 'TypeScript source.', 'Typed application / build logic.', 'Imported by other TS/JS/astro modules'],
  [/\.(js|mjs|cjs)$/i, 'JavaScript source.', 'Runtime or script logic.', 'Invoked directly or imported by modules'],
  [/\.(yml|yaml)$/i, 'YAML config.', 'Workflow / tool configuration.', 'Consumed by GitHub Actions or tooling'],
  [/\.(md|markdown)$/i, 'Markdown document.', 'Documentation or content.', 'Viewed in repo / site build'],
  [/package\.json$/i, 'Package manifest.', 'Defines deps & scripts.', 'Used by Node/npm & tooling'],
  [/tsconfig\.json$/i, 'TS config.', 'Compiler / module settings.', 'Consumed by tsc / vite / vitest'],
  [/\.gitignore$/i, 'Git ignore rules.', 'Exclude generated files.', 'Used by git operations']
];

function describeWhatWhy(path) {
  for (const [re, what, why, connects] of H) if (re.test(path)) return { what, why, connects };
  const bn = basename(path).toLowerCase();
  if (bn === '_headers') return { what: 'Netlify headers file.', why: 'Set custom security/caching headers.', connects: 'Consumed by Netlify deploy' };
  if (bn === '.env.example') return { what: 'Env var template.', why: 'Documents required environment variables.', connects: 'Used by developers / deployment' };
  if (bn === '.gitattributes') return { what: 'Git attributes.', why: 'Defines diff/merge or linguist settings.', connects: 'Used by git tooling' };
  if (path === '.husky/pre-commit') return { what: 'Git hook (pre-commit).', why: 'Runs quality checks before commit.', connects: 'Invoked by git via Husky' };
  if (path === '.husky/pre-push') return { what: 'Git hook (pre-push).', why: 'Runs tests/lint before push.', connects: 'Invoked by git via Husky' };
  if (bn === '.lighthouserc.json') return { what: 'Lighthouse config.', why: 'Defines performance audit settings.', connects: 'Used by LHCI workflow' };
  if (/^\d+$/.test(bn)) return { what: 'Stray numeric file.', why: 'Likely accidental / candidate for cleanup.', connects: 'Not referenced' };
  if (bn.endsWith('.log')) return { what: 'Log file.', why: 'Captured build or script output.', connects: 'Produced by scripts or CI' };
  if (bn === 'license') return { what: 'License file.', why: 'Specifies project licensing.', connects: 'Root metadata' };
  return { what: 'n/a', why: 'n/a', connects: 'n/a' };
}

const files = gitFiles().filter(keep).sort((a,b)=>a.localeCompare(b));
const rows = files.map(p => {
  const first = firstCommitInfo(p);
  const last = lastCommitInfo(p);
  const { what, why, connects } = describeWhatWhy(p);
  return { path: p, created: first.date, lastEdited: last.date, what, why, connects };
});

const now = new Date().toISOString();
let md = '';
md += `# Codebase Knowledge Base\n\n`;
md += `*Last updated: ${now}*\n\n`;
md += `| Path | Created | Last Edited | What | Why | Connects To |\n`;
md += `|------|---------|-------------|------|-----|-------------|\n`;
for (const r of rows) {
  md += `| \`${escapeMd(r.path)}\` | ${r.created} | ${r.lastEdited} | ${escapeMd(r.what)} | ${escapeMd(r.why)} | ${escapeMd(r.connects)} |\n`;
}
md += `\n> Timestamps from git history (first add + latest commit). Unknown purpose/connectivity -> n/a.\n`;

writeFileSync(OUT, md, 'utf8');
console.log(`Wrote ${OUT} with ${rows.length} files.`);

function escapeMd(s){return String(s).replace(/\|/g,'\\|').replace(/`/g,'\\`');}
